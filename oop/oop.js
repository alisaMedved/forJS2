/**
 * Объект. У объекта есть состояние (значения полей), есть поведение (методы его)
 * и на основе состояния и поведения можно сделать события.
 *
 * Инстанциирование - создание экземпляра класса (экземпляр = объект).
 *
 * Принципы ООП: инкапсуляция, абстракция, наследование, полиморфизм
 *
 * Абстрагирование - из моделей предметной области, из сущностей делаем классы. Из чего-то конкретного
 * делаем его модель и она уже называется абстракцией.
 * А еще бывают чистые абстракции - т.е. та абстракция которая не является молелью чего-то в предметной области,
 * нету воплощения этой абстракции в реальном мире. Например это сокет, или евент-эмиттер.
 *
 * Абстракция - это модель чего-то в предметной области или выдуманной вещи. Вторые называются Чистыми абстракциями.
 *
 * Инкапсуляция - это техника программирования, позволяющая строить абстракции,
 * объединяя поля и методы в один объект и скрывать внутренние поля и методы объекта от внешнего доступа.
 *
 * Сокрытие - это способ защиты внутренних полей и методов объекта от внешнего доступа.
 * Пометка: простановка модификатора о доступности данного метода (поведения).qqzz
 * Не во всех языках при инкапсуляции можно указать модификатор.
 *
 * Наследование - построение иеархии классов, когда какое-то поведение появляется у
 * базовых классов и потом оно распространяется на всех их потомках. Наследование поз-ет
 * переиспользование кода, обобщать (делать общий класс-предок с уникальными методами).
 *
 * Полиморфизм
 * №1 Полиморфизм типов т е когда у нас есть классы и когда мы насл-ем
 * от родителя интерфейс и можем его у потомка расширять.
 *
 * №2 П-м дженерик - какое-то св-во не объявляется какого оно типа, или аргумент функции не объявляется какого
 * он типа, а этот тип к нам приходит сверху и проставляется.
 *
 * Принципы второго порядка: SOLID, KISS, DRY, YAGNI, GRASP
 *
 * GRASP - general responsibility assigment software patterns -
 * Общие паттерны программного обеспечения для распределения ответственности
 * (распределение ответственности) -
 * это низкоуровневый принцип как лучше упорядочивать код,
 * чтобы управлять сцеплением классов, как много знают классы друг о друге.
 *
 * Их девять
 *
 * High Cohesion - высокая связность - должна быть высокая связность внутри модуля/компонента
 *
 * Low Coupling - низкое зацепление - должно быть низкое зацепление между модулями
 *
 * Information Expert - каждый класс должен быть самодостаточным
 * (сам без чьей-то помощи должен моделировать свою сущность,
 * сам экспертом тех данных, которые в нем инкапсулированы)
 *
 * Creator - этот принцип отвечает на вопрос "Кто должен создавать инстанц?" -
 *
 * 1) Как понять какой класс должен инстанциировать другой класс? и ответ таков:
 * если один класс аггрегирует или содержит инстанцы другого, то есть они могут быть значениями его полей,
 * то он может их и инстанциировать. Если у нас есть аггрегация или композиция, тот класс который
 * занимается агрегацией/композицией других тот и может инстанциировать их,
 * принимать как аргумент конструктора и сохранять у себя.
 *
 * 2) Или в некоторых случаях та абстракция которая
 * тесно работает над другой: подписывается на нее, изменяет ее, то этой абстракции следует и инстанциировать
 * эту другую, и хранить ссылку на нее (как только ссылка потеряна - Gorbage Collection съедает этот инстанц),
 * и удалять ее.
 *
 * 3) Еще кто может заниматься инстанциированием? Та програмная компонента, которая может наполнить инфой этот инстанц,
 * проинициализировать его или
 * просто мочь хранить большое количество данных инстанцов в коллекции и мочь делать вторичную инициализацию.
 * Яркий пример этого: пул
 *
 * Другие примеры этого принципа: конечно же конструктор и фабрика.
 *
 * Controller - у модели предметной области, которая построена на классах,
 * есть взаймодествие с внешним миром и должно оно осуществляться через контролеры (внешний интерфейс).
 * Точка входа для взаймодействия плюс изоляция/сокрытие внутреннего кода от внешнего пользователя.
 * Яркие примеры: фасад, изоляция слоев, команды.
 *
 * Pure Fabrication - чистая выдумка - event emitter это можель чего в реальном мире?
 * Правильно ее нет в реал мире - это чистая выдумка. - абстракция которой нет в предметной области
 * и она позволяет снизить зацепление классов предметной области
 *
 * Polymorphism
 * Проблема: альтернативное поведение на основании типа.
 * Решение: заменяем if и switch case на полиморфизм и наследование, обращаемся через интерфейс или абстрактный класс.
 * Вообщем берешь делаешь один абстрактный класс, от него кучу наследников.
 * Все наследники будут иметь одинакового названия метод.
 * Но поведение под капотом у всех разное в этом методе. Вот так на основании чьим инстанцем является,
 * той вариации метода/поведения
 * он и следует.
 *
 * Indirection - если мы хотим создать два класса, которые вз-ют но при этом должны разумеется
 * мало знать друг о друге. Тогда мы можем создать третий класс, который знает о них обоих. Уменьшение сцепления.
 * Яркий пример: паттерн mediator, MVC C - controller - тот самый посредник.
 *
 * Protected Variations - мы должны так строить свои классы
 * и отношения между ними чтобы снизить количество изменений в случае изменений одной сущности.
 * Защита абстракций от изменений путем спецификации интерфейсов или контрактов и взаймодействию через них.
 *
 * Паттерны или шаблоны: GoF.
 * GoF - реализация controller.
 * Паттерн - это идея, которую можно переиспользовать. Каждый паттерн можно реализовать по-разному.
 *
 * SOLID - это высокоуровневый принцип.
 * Облегчение модификации и расширения
 * Улучшение владения кодом и ТТМ
 * Спсобность быстро понимать друг друга
 *
 * SOLID был создан чтобы побороть проблему: Когда что-то меняется со стороны бизнеса все рушится
 * и все ссука переделывается с корней.
 *
 * Принцип подстановки Барбара-Лисков - когда мы можем подменять базовые классы их наследниками,
 * а точнее наследники всегда должны соответсвовать правилам интерфейса родителя.
 *
 * Opened Closed - для того чтобы выполнялся принцип Барбары-Лисков класс
 * должен быть открыт для рассширения, но закрыт для изменения.
 *
 * Single Responsibility - каждый класс должен модилеровать ТОЛЬКО ОДНУ сущность.
 *
 * Interface Segregation - интерфейсы надо дробить и нельзя делать God Class
 * (охох вспоминаем наши сторы и response и сущности беков)
 *
 * Dependency Inversion - высокоуровневые классы не должны быть завязаны на низкоуровневые.
 * Должны быть общие абстракции и на них должны быть завязаны и низкоуровневые и высоуровневые,
 * а лучше на интерфесы.
 *
 * Gang of Four - 23 шаблона проектирования.
 * Эти 23 шаблона они разбили на 4-ре группы
 * Порождающие - инстанциирование - абстрактная фабрика, строитель, фабричный метод, пул, синглтон...
 * Структурные - структура кода - адаптер, мост, компоновщик, декоратор или обертка, фасад, прокси...
 * Поведенческие - моделировать поведение, развернутое во времени, в виде абстракций - цепочка обязанностей,
 * команда, обсервер, итератор, стратегия...
 * Коммуникационные - cqs, cqrs, event sourcing...
 *
 */